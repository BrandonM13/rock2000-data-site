<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rock 2000 – Artist Search</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-50 text-gray-900">
  <main class="max-w-3xl mx-auto p-6">
    <h1 class="text-3xl font-bold mb-4">Rock 2000 – Artist Search</h1>

    <section class="bg-white rounded-2xl shadow p-4">
      <p class="text-sm text-gray-600 mb-3">Type the artist exactly as in your sheet for now. (We can add fuzzy later.)</p>
      <label class="block text-sm mb-1">Artist</label>
      <div class="flex gap-2">
        <input id="artistName" class="flex-1 border rounded px-3 py-2" placeholder="e.g., IRON MAIDEN" />
        <button id="artistBtn" class="rounded-2xl px-4 py-2 bg-black text-white">Search</button>
      </div>
      <div id="status" class="mt-3 text-xs text-gray-500"></div>
      <div id="artistResult" class="mt-4 text-sm"></div>
    </section>

    <p class="mt-6 text-xs text-gray-500">Static site; reads Google Sheets via GViz JSON. No costs.</p>
  </main>

  <script>
    // ===== CONFIG =====
    const SHEET_ID = "1xlSqIR-ZjTaZB5Ghn4UmoryKxdcjyvFUKfCqI299fnE"; // your sheet
    const SHEET_TAB = "MasterCountdownData"; // tab with the wide table

    // Column name synonyms (case-insensitive)
    const EXPECTED = {
      song:   ["all_caps_title", "song", "title", "song_title", "all caps title"],
      artist: ["all_caps_artist", "artist", "artist_name", "all caps artist"],
      key:    ["key", "master_key", "song|artist", "song_artist_key"],
      album:  ["album"],
      change: ["change"],
      year:   ["year", "release_year", "yr"], // used only if present in tall layouts
      rank:   ["rank", "position"],            // used only if present in tall layouts
      duration: ["duration", "duration (mm:ss)", "mm:ss", "duration_ms", "duration (ms)"]
    };

    // ===== Helpers =====
    async function fetchSheet(sheetName) {
      const url = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:json&sheet=${encodeURIComponent(sheetName)}`;
      const res = await fetch(url, { cache: "no-store" });
      const text = await res.text();
      // Expect wrapper like: google.visualization.Query.setResponse({...})
      const json = JSON.parse(text.substring(text.indexOf('{'), text.lastIndexOf('}') + 1));
      const cols = json.table.cols.map(c => (c.label || c.id || "").trim());
      const rows = (json.table.rows || []).map(r => (r.c || []).map(c => (c ? c.v : "")));
      return { cols, rows };
    }

    function indexOfHeader(cols, candidates) {
      const lower = cols.map(c => c.toString().trim().toLowerCase());
      for (const cand of candidates) {
        const i = lower.indexOf(cand);
        if (i !== -1) return i;
      }
      return -1;
    }

    function normalize(s) {
      return (s || "")
        .toString()
        .normalize("NFKD")
        .toUpperCase()
        .replace(/&/g, "AND")
        .replace(/['"`]/g, "")
        .replace(/\s+/g, " ")
        .trim();
    }

    function statsForEntries(entries) {
      if (!entries.length) return null;
      const years = entries.map(e => Number(e.year)).filter(n => !isNaN(n));
      const ranks = entries.map(e => Number(e.rank)).filter(n => !isNaN(n));
      return {
        mostRecent: years.length ? Math.max(...years) : "",
        best: ranks.length ? Math.min(...ranks) : null,
        worst: ranks.length ? Math.max(...ranks) : null,
        avg: ranks.length ? Math.round(ranks.reduce((a,b)=>a+b,0)/ranks.length) : null,
        total: entries.length,
      };
    }

    // ===== Data & Index =====
    let INDEX_BY_ARTIST = new Map();

    async function loadAndIndex() {
      const status = document.getElementById('status');
      status.textContent = 'Loading…';
      const { cols, rows } = await fetchSheet(SHEET_TAB);

      const iSong   = indexOfHeader(cols, EXPECTED.song);
      const iArtist = indexOfHeader(cols, EXPECTED.artist);
      const iKey    = indexOfHeader(cols, EXPECTED.key);
      const iAlbum  = indexOfHeader(cols, EXPECTED.album);
      const iChange = indexOfHeader(cols, EXPECTED.change);
      const iYear   = indexOfHeader(cols, EXPECTED.year);
      const iRank   = indexOfHeader(cols, EXPECTED.rank);
      const iDur    = indexOfHeader(cols, EXPECTED.duration);

      // Detect wide layout: columns that are 4-digit years (optionally like "2025 rank")
      const yearCols = cols
        .map((c, idx) => ({ name: (c || "").toString().trim(), idx }))
        .filter(o => /^\d{4}(?:\s*rank)?$/i.test(o.name));

      const tallLayout = (iYear !== -1 && iRank !== -1 && (iSong !== -1 || iKey !== -1) && (iArtist !== -1 || iKey !== -1));
      const wideLayout = (!tallLayout && yearCols.length > 0 && (iSong !== -1 || iKey !== -1) && (iArtist !== -1 || iKey !== -1));

      const flat = [];

      if (tallLayout) {
        for (const r of rows) {
          let song = iSong !== -1 ? r[iSong] : "";
          let artist = iArtist !== -1 ? r[iArtist] : "";
          if ((!song || !artist) && iKey !== -1 && r[iKey]) {
            const parts = String(r[iKey]).split("|");
            song = song || (parts[0] || "");
            artist = artist || (parts[1] || "");
          }
          if (!(song || artist)) continue;
          flat.push({
            year: iYear !== -1 ? r[iYear] : "",
            rank: iRank !== -1 ? r[iRank] : "",
            song, artist,
            change: iChange !== -1 ? r[iChange] : "",
            album: iAlbum !== -1 ? r[iAlbum] : "",
            duration: iDur !== -1 ? r[iDur] : "",
          });
        }
      } else if (wideLayout) {
        for (const r of rows) {
          let song = iSong !== -1 ? r[iSong] : "";
          let artist = iArtist !== -1 ? r[iArtist] : "";
          if ((!song || !artist) && iKey !== -1 && r[iKey]) {
            const parts = String(r[iKey]).split("|");
            song = song || (parts[0] || "");
            artist = artist || (parts[1] || "");
          }
          if (!(song || artist)) continue;
          for (const yc of yearCols) {
            const yr = yc.name.replace(/\s*rank$/i, "");
            const rk = r[yc.idx];
            if (rk !== null && rk !== "" && typeof rk !== "undefined") {
              flat.push({
                year: yr,
                rank: rk,
                song, artist,
                change: iChange !== -1 ? r[iChange] : "",
                album: iAlbum !== -1 ? r[iAlbum] : "",
                duration: iDur !== -1 ? r[iDur] : "",
              });
            }
          }
        }
      } else {
        // Best-effort fallback
        for (const r of rows) {
          const s = iSong !== -1 ? r[iSong] : "";
          const a = iArtist !== -1 ? r[iArtist] : "";
          if (s || a) flat.push({ year: "", rank: "", song: s, artist: a, change: "", album: iAlbum !== -1 ? r[iAlbum] : "", duration: iDur !== -1 ? r[iDur] : "" });
        }
      }

      // Build index by artist
      INDEX_BY_ARTIST.clear();
      for (const row of flat) {
        const key = normalize(row.artist);
        if (!INDEX_BY_ARTIST.has(key)) INDEX_BY_ARTIST.set(key, []);
        INDEX_BY_ARTIST.get(key).push(row);
      }

      status.textContent = `Loaded ${flat.length} rows · Artists indexed: ${INDEX_BY_ARTIST.size}`;
      console.log("Artist index ready:", { rows: flat.length, artists: INDEX_BY_ARTIST.size, sampleCols: cols });
    }

    function renderArtist(entries, el) {
      if (!entries || !entries.length) { el.innerHTML = `<div class="text-gray-500">No matches</div>`; return; }
      const s = statsForEntries(entries);
      entries.sort((a,b)=> (Number(a.year)||0) - (Number(b.year)||0));
      const rows = entries.map(e => `<tr>
        <td class="px-2 py-1">${e.year}</td>
        <td class="px-2 py-1">${e.rank}</td>
        <td class="px-2 py-1">${e.song}</td>
      </tr>`).join("");
      el.innerHTML = `
        <div class="mb-2">Latest <strong>${s.mostRecent || ""}</strong> · Best <strong>#${s.best ?? ""}</strong> · Avg <strong>#${s.avg ?? ""}</strong> · Total <strong>${s.total}</strong></div>
        <div class="overflow-auto max-h-80 border rounded">
          <table class="text-xs w-full">
            <thead class="bg-gray-100 sticky top-0"><tr>
              <th class="text-left px-2 py-1">Year</th>
              <th class="text-left px-2 py-1">Rank</th>
              <th class="text-left px-2 py-1">Song</th>
            </tr></thead>
            <tbody>${rows}</tbody>
          </table>
        </div>
      `;
    }

    // Boot
    (async function init(){
      try { await loadAndIndex(); }
      catch (e) {
        console.error(e);
        document.getElementById('status').textContent = 'Failed to load. Check Publish/Share permissions and tab name.';
        return;
      }

      document.getElementById('artistBtn').onclick = () => {
        const a = normalize(document.getElementById('artistName').value);
        const entries = INDEX_BY_ARTIST.get(a) || [];
        renderArtist(entries, document.getElementById('artistResult'));
      };
    })();
  </script>
</body>
</html>
